import{j as e,q as r}from"./index-B5kjSQ-4.js";import{H as a}from"./Helmet-0C35p9Ai.js";import{s as l,P as m}from"./project_pages.module-DCPvog_1.js";const u=()=>{const{PaperLink:i,GitHubLink:n,ShortName:t,FullTitle:s,DOI:o}=r;return e.jsxs(e.Fragment,{children:[e.jsx(a,{children:e.jsxs("title",{children:["Alan Romano | ",t]})}),e.jsx("h1",{className:"title "+l.titleFit,children:s}),e.jsxs("div",{className:"readable-content",children:[e.jsx(m,{doi:o,link:i}),e.jsx("p",{children:"In this project, we investigate the effects of function inlining optimizations on WebAssembly modules. We find that these optimizations can result in in slower WebAssembly module runtime performance when applied. We inspect the LLVM and Binaryen inlining optimization passes used in the Emscripten C/C++-to-WebAssembly compiler. We inspect 127 C/C++ samples from the LLVM test suite and find that 66 samples exhibit counterintuitive runtime behavior due to function inlining. This behavior is seen when inlining hot functions into long-running functions. We hope our findings motivate further work on revising existing optimizations with the unique characteristics of WebAssembly environments in mind."}),e.jsx("br",{}),e.jsxs("p",{children:["The data collected from our study is available as on our project's Â ",e.jsx("a",{href:n,children:"Zenodo page"}),"."]}),e.jsx("br",{}),e.jsx("br",{})]})]})};export{u as default};
